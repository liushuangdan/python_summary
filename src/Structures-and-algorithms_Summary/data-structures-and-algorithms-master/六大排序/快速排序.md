快速排序

快速排序是才能够冒泡排序演变而来的算法，但是比冒泡排序要高效的多，所以叫做快速排序。

快速排序之所以快速，是因为它使用了【分治法】

同冒泡排序一样，快速排序也属于**交换排序**，通过元素之间的比较和交换位置来达到排序的目的。

不同的是，冒泡排序在每一轮只把一个元素冒泡到数列的一端，而快速排序**在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分。**

![](images\快速排序.png)

这种思路就叫做**分治法**。

每次把数列分成两部分，究竟有什么好处呢？

假如给定8个元素的数列，一般情况下冒泡排序需要比较8轮，每轮把一个元素移动到数列一端，时间复杂度是O（n^2）。



![](images\快速排序2.png)

如图所示，在分治法的思想下，原数列在每一轮被拆分成两部分，每一部分在下一轮又分别被拆分成两部分，直到不可再分为止。

这样一共需要多少轮呢？平均情况下需要logn轮，因此快速排序算法的平均时间复杂度是 **O（nlogn）**。

基准元素的选择，以及元素的移动，都是快速排序的核心问题。

**基准元素的选择**

基准元素，英文pivot，用于在分治过程中以此为中心，把其他元素移动到基准元素的左右两边。

那么基准元素如何选择呢？

最简单的方式是选择数列的第一个元素：

最右边或者最左边的元素。

这种选择在绝大多数情况是没有问题的。但是，假如有一个原本逆序的数列，期望排序成顺序数列，那么会出现什么情况呢？

![](images\快速排序3.png)

整个数列并没有被分成一半一半，每一轮仅仅确定了基准 元素的位置，

这种情况下数列第一个元素要么是最小值，要么是最大值，根本无法发挥分治法的优势。

在这种极端情况下，快速排序需要进行N轮，时间复杂度退化成了O（N……2）

为了避免上面的情况发生，我们可以不选择数列的第一个元素，而是随机选择一个元素作为基准元素，

这样一来，即使在数列完全逆序的情况下，也可以有效地将数列分成两部分。

当然，即使是随机选择基准元素，每一次也有极小的几率选到数列的最大值或最小值，同样会影响到分治的效果。

所以，快速排序的平均时间复杂度是 **O（n****logn），**最坏情况下的时间复杂度是 **O（n^2）**。

#### 一下就是分治法的代码的实现：

___

### 代码的实现：

```python
#快排的主函数，传入参数为一个列表，左右两端的下标
def QuickSort(array,leftIndex=0,rightIndex=None):
    #数组的长度
    arrayLen = len(array)
    #长度为1 的话 或者 空 的话 直接返回 数组
    if arrayLen <= 1:
        return array
    #程序一开始 如果没有给一个最右边的索引值导入话，那么我们就给它 赋值一个 就是数组的最右边的 那个索引值。
    if rightIndex == None:
        rightIndex = arrayLen - 1
    # 保护条件，只有满足  左边索引小于右边索引的时候 再开始排序
    if leftIndex < rightIndex:
        #找到 基准的 索引值 传入参数，通过Partitions函数，获取k下标值
        pivot = partition(array,leftIndex,rightIndex)
        #递归前后半区 对基准前面不部分继续快排
        QuickSort(array,leftIndex,pivot - 1)
        #对基准后半积分继续快排
        QuickSort(array,pivot + 1,rightIndex)

```

___

### 元素的移动

选定了基准元素以后，我们要做的就是把其他元素当中小于基准元素的都移动到基准元素一边，大于基准元素的都移动到基准元素另一边。       



#### 1.交换指针法：

何谓指针交换法？我们来看一看详细过程。

给定原始数列如下，要求从小到大排序：

![](images\1.png)

开局和挖坑法相似，我们首先选定基准元素Pivot，并且设置两个指针left和right，指向数列的最左和最右两个元素：

![](images\2.png)

接下来是**第一次循环**，从right指针开始，把指针所指向的元素和基准元素做比较。如果**大于等于**pivot，则指针向**左**移动；如果**小于**pivot，则right指针停止移动，切换到**left**指针。

在当前数列中，1<4，所以right直接停止移动，换到left指针，进行下一步行动。

轮到left指针行动，把指针所指向的元素和基准元素做比较。如果**小于等于**pivot，则指针向**右**移动；如果**大于**pivot，则left指针停止移动。

由于left一开始指向的是基准元素，判断肯定相等，所以left右移一位。

![](images\11.png)

由于7 > 4，left指针在元素7的位置停下。这时候，我们让**left和right指向的元素进行交换**。

![](images\12.png)

接下来，我们进入**第二次循环**，重新切换到right向左移动。right先移动到8，8>4，继续左移。由于2<4，停止在2的位置。



![](images\13.png)

切换到left，6>4，停止在6的位置。

![](images\14.png)

元素6和2交换。

![](images\15.png)

进入**第三次循环**，right移动到元素3停止，left移动到元素5停止。

![](images\16.png)

元素5和3交换。



![](images\17.png)

进入**第四次循环**，right移动到元素3停止，这时候请注意，left和right指针已经重合在了一起。

![](images\18.png)

当left和right指针重合之时，我们让pivot元素和left与right重合点的元素进行交换。此时数列左边的元素都小于4，数列右边的元素都大于4，这一轮交换终告结束。

![](images\19.png)

#### 以下为交换指针实现的partition的代码：

```python
def partition(array,leftIndex,rightIndex):

    pivotValue = array[rightIndex]

    #将最左侧的 索引值 给 i

    i  = leftIndex

    #将最右侧的 索引的前一个 给j

    j = rightIndex -1

    #当left下标，小于right下标的情况下，此时判断二者移动是否相交，若未相交，则一直循环

    while i < j:

        # 当left对应的值大于锚点 基准点 参考值，就一直向左移动

        while j > leftIndex and array[j] > pivotValue:

            j -= 1

        #当left对应的值小于基准点参考值，就一直向右移动

        while i < rightIndex and array[i] <= pivotValue:

            i += 1

        #若移动完，二者仍未相遇则交换下标对应的值

        if i < j:

            array[j],array[i] = array[i],array[j]

            i+=1

            j-=1

    #若移动完，已经相遇，则交换right对应的值和参考值

    array[i],array[rightIndex] = array[rightIndex],array[i]

    # 返回 一个 索引值

    return i

```

___

#### 2.挖坑法： 坑就是 基准数 的位置。

我们来做个详解：

排序 从小到大

![](images\1.png)

首先，我们选定基准元素Pivot，并记住这个位置index，这个位置相当于一个“坑”。并且设置两个指针left和right，指向数列的最左和最右两个元素。

![](images\2.png)

接下来，从right指针开始，把指针所指向的元素和基准元素做比较。如果比pivot大，则right指针向左移动；如果比pivot小，则把right所指向的元素填入坑中。

在当前数列中，1<4，所以把1填入基准元素所在位置，也就是坑的位置。这时候，元素1本来所在的位置成为了新的坑。同时，left向右移动一位

![](images\3.png)

##### 此时，left左边绿色的区域代表着小于基准元素的区域。

接下来，我们切换到left指针进行比较。如果left指向的元素小于pivot，则left指针向右移动；如果元素大于pivot，则把left指向的元素填入坑中。

在当前数列中，7>4，所以把7填入index的位置。这时候元素7本来的位置成为了新的坑。同时，right向左移动一位。

![](images\4.png)

##### 此时，right右边橙色的区域代表着大于基准元素的区域。

下面按照刚才的思路继续排序：

8>4，元素位置不变，right左移

![](images\5.png)

2<4，用2来填坑，left右移，切换到left。

![](images\7.png)

6>4，用6来填坑，right左移，切换到right。

![](images\6.png)

3<4，用3来填坑，left右移，切换到left。

![](images\8.png)

5>4，用5来填坑，right右移。这时候left和right重合在了同一位置。

![](images\9.png)

这时候，把之前的pivot元素，也就是4放到index的位置。此时数列左边的元素都小于4，数列右边的元素都大于4，这一轮交换终告结束。

![](images\10.png)

一下就是挖坑法的代码的实现。如果比基准数大那么就不用移动位置，，如果比基准数小那么就去基准数后面的坑的位置。



```python

# 《算法导论》中的快排程序
def partition2(array,leftIndex,rightIndex):
    #设置一个 左边的指针位置 为 左侧的 前一个
    i = leftIndex -1
    #遍历 除 基准数之外的 数
    for j in range(leftIndex,rightIndex):
        #比较 遍历的数 和 基准数 ，若是小于基准数 则 换到数组前面去
        if array[j] < array[rightIndex]:
            #交换位置，将遍历的比 基准数小的数 放到 我们指针 的 后一个上，然后 这个时候指针向后移一位。当遍历的数大于我们的基准数的时候，不移动，而且 指针也不发生变化，那么 当我们遍历完一圈以后，把 我们的基准数 放到 索引i 的后一个 位置，那么就形成了 一个 基准数 左边都是比它小的数，基准数右边 都是比它大的数 这样的模式。然后要把 索引 i 的后一个位置 作为基准数 与 原基准数 交换位置，进而可以第二次来 遍历比较。
            array[j],array[i+1] = array[i+1],array[j]
            i += 1
    #遍历完了以后，将 left 位置上的数 和 最后一个 数  即 right 上的数互换位置，就 重置 基准数了。
    array[rightIndex],array[i+1] = array[i+1],array[rightIndex]
    #返回基准的下标
    return i+1
```



